Using Salesforce Features with Apex: 
Actions: 
Create actions -  let users create records
Custom actions - invoke Lightning components, flows, Visualforce pages, or canvas apps with  custom functionality    
global custom actions - for tasks that don’t require users to use records that have a relationship to a specific object.
Object-specific custom actions - let users interact with or create records that have a relationship to an object record
create, Log a Call, and custom actions, you can create either object-specific actions or global actions.
Update actions must be object-specific.

Create Global Quick Actions:
Global create actions enable users to create object records, but the new record has (no direct relationship) with other records.
Global quick actions (aren’t context-aware), so fields can’t be populated with information from the current page.
Instead, add the appropriate quick action to a page to (specify predefined fields).
Global actions live on a special layout of their own, known as the (global publisher layout)
object page layout isn’t customized - > the actions on those object record pages are inherited from the global publisher layout.

different things with global quick actions:

add a Send Email action to the global layout -> use anywhere in Lightning exp.
*You can’t add a global Send Email action to the Cases layout or use the action with cases.*

Add Log a Call actions to global layouts
In Lightning Experience, Log a Call actions on global layouts display in the Global Actions menu.
* have only one Log A Call action else mobile see full Task layout*

Canvas apps in custom actions require Publisher as a location.
Lightning components in custom actions, you must have My Domain deployed
Visualforce pages  in  custom actions, cant have standard controllers.
/*
you want a custom action where 
users enter a street address,
see a map,
the local time 
and the local weather    - use VF page with no standard controller.
*/

global Create a Record quick action->enable  Salesforce for Outlook users to create records directly from the SF side panel

Chatter groups with customers don’t support global create, log a call, or custom actions and display
Chatter groups with customers only has standard Chatter actions, such as Post, File, Link, and Poll. 

Actions to create records for an object that is the detail object in a master-detail relationship must be object-specific

how to Create Global Quick Actions: 

can add global actions to any page that supports actions
Home page, the Chatter tab, object pages, and custom Lightning app pages

1.Setup
2.Global Actions
3.New Action.
4.select the type of action(create/ select a Visualforce page or canvas app(give Height,Width)/Select Ltng Cmp)
5. for Create a Record, Update a Record, or Log a Call action, 
you can add a custom success message that displays after the action executes successfully.

Set Predefined Field Values: 
For single-select picklists, you can specify both a specific value and a formula value.
If you set both, the formula value takes precedence over the specific value.

On object-specific actions, the predefined value can include references to the source object and its related objects.

can't set Multi-select picklists.
can’t use a dependent picklist to set a predefined value.
the action uses the predefined value, not the default value.
Formulas can’t reference fields on external objects

for email action’s recipient
Contact, lead, and person account IDs are supported.
Use an ID field if you want to log the email on the recipient’s record.
Use a string field to predefine an email recipient for a custom object or custom field.(cant log on rec)

Create Object-Specific Actions : 

flow is there in object specific action
Object-specific actions are only available on page layouts for that object. 
For example, you can add the only to the group publisher layout.

creates a record by using an object-specific create action, a feed item for that record appears:
The Visualforce page for an object-specific custom action must include the standard controller for the relevant object.
Object-specific Send Email actions, available only on cases, it has no global email action.

you can choose as a target object an event, a task, or any object that has a parent-child or lookup relationship to the host object.
You can’t choose Quote as a target object from Opportunity.

1. management settings for the object
2. New Action.

If the object for which you’re creating the action has more than one relationship with the target object,
select the field you want to populate when a record is created

If master detail , you can’t select which field to populate, MD selected by default. make it read only to avoid editing.

Class: 

QuickAction Class:

to know how this record got created from Quick action or not.
eg : on contact trigger 
for (Contact c : Trigger.new) {
if (c.getQuickActionName() == QuickAction.CreateContact) {
// global action
}
if (c.getQuickActionName() == Schema.Account.QuickAction.CreateContact) {
//object specific action 
}
}

eg: perform global QA via apex 
public Id globalCreate(Contact c) { 
QuickAction.QuickActionRequest req = new QuickAction.QuickActionRequest();
req.quickActionName = QuickAction.CreateContact; // global
req.quickActionName = Schema.Account.QuickAction.AccountCreateContact;// object specific
req.record = c;
req.contextid = '001xx000003DGcO'; // in case of object specific give (parent ID) 
QuickAction.QuickActionResult res = QuickAction.performQuickAction(req);
return c.id;
}

DescribeQuickActionResult Class:
describe metadata information for a quick action.
LAYOUT - ROW - ITEM - COMPONENT

Approval Processing: 

approval process automates how records are approved in Salesforce.
Approval.process method uses : 
to submit an approval request
Approve or reject existing approval requests

Approval.process - count against DML.
Record lock and unlock - count as DML
They’re blocked before a callout.
ProcessRequest  > parent of ProcessSubmitRequest & ProcessWorkitemRequest

//submit for approval 
Approval.ProcessSubmitRequest req1 = 
new Approval.ProcessSubmitRequest();
req1.setComments('Submitting request for approval.');
req1.setObjectId(a.id);
// Submit on behalf of a specific submitter
req1.setSubmitterId(user1.Id); 
// Submit the record to specific process and skip the criteria evaluation
req1.setProcessDefinitionNameOrId('PTO_Request_Process');
req1.setSkipEntryCriteria(true);
// Submit the approval request for the account
Approval.ProcessResult result = Approval.process(req1);

// Verify the result
System.assert(result.isSuccess());

System.assertEquals(
'Pending', result.getInstanceStatus(), 
'Instance Status'+result.getInstanceStatus());

// Approve the submitted request
// First, get the ID of the newly created item
List<Id> newWorkItemIds = result.getNewWorkitemIds();

// Instantiate the new ProcessWorkitemRequest object and populate it
Approval.ProcessWorkitemRequest req2 = 
new Approval.ProcessWorkitemRequest();
req2.setComments('Approving request.');
req2.setAction('Approve'); //Valid values are: Approve, Reject, or Removed. Only system administrators can specify Removed.
req2.setNextApproverIds(new Id[] {UserInfo.getUserId()});

// Use the ID from the newly created item to specify the item to be worked
req2.setWorkitemId(newWorkItemIds.get(0));

// Submit the request for approval
Approval.ProcessResult result2 =  Approval.process(req2);

Authentication:
create a custom OAuth-based authentication provider plug-in for single sign-on (SSO) to Salesforce.
default support by SF for SSO ->service providers that implement the OpenID Connect protocol.

you must create a custom metadata type record for your authentication provider
you must still call getUserInfo in the custom authentication handler to avoid getting errors about mixing objects
insert a contact in the Auth.RegistrationHandler.createUser method

extends Auth.AuthProviderPluginClass (abstract)
define methods -> getCustomMetadataType, initiate,handleCallback,getUserInfo.

Chatter : 
use zones to organize ideas and answers into groups
Each zone can have its own focus, with unique ideas and answers topics to match that focus

Answers Class:
Represents zone answers
->Answers.findSimilar(question);
->Answers.setBestReply(questionId,replyId);

Ideas Class
Represents zone ideas.
userId -> req communityID->optional if empty get all recent reply for user.
Community -> = [ SELECT Id FROM Community WHERE Name = 'INTERNAL_IDEAS' ];
Idea idea = new Idea ();
Ideas.getUnreadRecentReplies(UserInfo.getUserId(), '');
[SELECT Id, Title FROM Idea WHERE Id IN :recentRepliesIds]
->findSimilar(idea)
->getAllRecentReplies(userID, communityID)
->getReadRecentReplies(userID, communityID)
->getUnreadRecentReplies(userID, communityID)
->markRead(ideaID)

Zones class : 
organize ques into logical group , own focus and unique question.
ZoneSearchResultType enum value -> Article,Question

Chatter : 
ConnectApi namespace is referred to as Chatter in Apex.
It doesn’t run in system mode like other Apex code.
we can Create triggers that update Chatter feeds.

Action Links: 
action link is a button on a feed element.
take a user to a Web page, initiate a file download, or 
invoke an API call to Salesforce or to an external server
includes a URL and an HTTP method,
and can include a request body and header information, such as an OAuth token for authentication.
use this so that users can (take action to drive productivity and accelerate innovation.)

1. create action link template
2. define an action link group that contains at least one action link.
ConnectApi.ActionLinks.createActionLinkGroupDefinition(communityId, actionLinkGroup)
3. post a feed element and associate the action link with it.
ConnectApi.ChatterFeeds.postFeedElement(communityId, feedElement)

Type of Action Links:
Api(sync) , ApiAsync(async) , Download, Ui.

After the action link group is instantiated, the values are stored in an encrypted format, passed via binding.
actionURL, headers, and requestBody - not instantiated from template - encrypted.
where as in action link template are not encrypted (above ones).
binding values used when instantiating an action link group from a template are encrypted
Don’t store sensitive information in templates. 
Use binding variables to add sensitive information when you instantiate the action link group.

can’t specify both excludeUserId and userId for an action link.

However, you can’t add new binding variables.

Primary(3 templates) displays action link groups in the body of feed elements.
Overflow(4 templates) displays action link groups in the overflow menu of feed elements.

number of Executions Allowed - unlimited we cant use type as Api(sync) , ApiAsync(async).

Hours until Expiration - 8760

features of managed packages, such as 
listing on the AppExchange,
push upgrades, 
post-install Apex scripts,
license management, 
and enhanced subscriber support.

The Chatter feed became a container of feed elements. after 31v api.
Capabilities provide a consistent way to interact with objects in the feed.
to know what fn avaialble -> . Inspect the capability object not feed element.
ConnectApi.FeedElement.capabilities 
posting a feed element, specify its characteristics in the ConnectApi.FeedElementInput.capabilities property.
ConnectApi.FeedItem is a subclass of ConnectApi.FeedElement.

ConnectApi.FeedItem.actor
ConnectApi.FeedElement.header
ConnectApi.FeedElement.body
ConnectApi.FeedElement.capabilities
ConnectApi.FeedElement.capabilities.bundle.changes

If a user can see the parent of the feed element, the user can see the feed element.
ConnectApi.FeedType - enum -> News,Topic,Stream etc.

ConnectApi.ChatterFeeds.getFeedElementsFromFeed
ConnectApi.ChatterFavorites.getFeedElements

post to myself.
ConnectApi.FeedElement feedElement = ConnectApi.ChatterFeeds.postFeedElement(null, 'me', ConnectApi.FeedElementType.FeedItem, 'Working from home today.');

To access the data in a partner portal or a Customer Portal, 
use a community ID for the communityId argument. You cannot use 'internal' or null.

/connect/communities/communityId/resource
or 
/connect/communities/internal/resource

if null : 
/connect/resource
/chatter/resourc

JSON and JSONParser classes:
serialize Chatter in Apex outputs to JSON,
deserialize Chatter in Apex inputs from JSON.

json - input - chatter in apex -> output - > json 

only output got serialized , top level input got  deserializes.
Enum values and exceptions cannot be serialized or deserialized.

ConnectApi Versioning and Equality Checking:

apex class(v 41) has method for calling chatter api. so those ConnectApi method call executes in the context of the version of the class.
ConnectApi output object has getBuildVersion method
apex class (v41) so can access properties of input objects belong to version 41 only.
if input contains version inapproriate properties -> exception.
output of toString has only version appropriate properties.
deserialization and serialize also support version related properties only.
Enums are not versioned. 

Equality checking : 
Input objects—properties are compared.
output -> properties and version are compared , if diff version its diff objects.

Casting ConnectApi Objects: 

downcast some ConnectApi is useful for 
message segments - ConnectApi.MessageSegment
feed item capabilities - ConnectApi.FeedItemCapability
and record fields - ConnectApi.AbstractRecordField

before downcaste: 
At runtime 
use instanceof() to check the concrete types of these objects and then safely proceed with the corresponding downcast
Your code should always be prepared to handle instances of unknown subclasses.

Chatter REST API request:
/chatter/feed-elements?q=chat*
chatter in apex:
ConnectApi.ChatterFeeds.searchFeedElements(null, 'chat*');

wildcard accepted in chatter : 
* , ? -> You can't use a ? in a lookup search.
you must enclose your search string in quotation marks and you must escape the special character.  if searching for "name\?"

Chatter in Apex doesn’t support the runAs system method.
Most Chatter in Apex methods  should be @IsTest(SeeAllData=true). else failed 

some Chatter in Apex methods, such as getFeedElementsFromFeed, 
are not permitted to access organization data in tests and must be used with special test methods 
that register outputs to be returned in a test context.
eg: test.setTest-----
test method signature is same as regular method signature.
chatter in apex testing == web service testing
build data ->(create output object and set properties)
call the test method to register the data
user regualr method will return the registered data.
if no data registedred exception thrown
eg:
ConnectApi.ChatterFeeds.setTestGetFeedElementsFromFeed(null,ConnectApi.FeedType.News, 'me', testPage);

diff btw connect api class and other class : 
Chatter in Apex methods don’t run in system mode, they run in the context of the current user
string "me" to specify the context user instead of an ID.(subjectId)
Chatter in Apex ignores the with sharing and without sharing keywords
if your code adds a feed item for a user, it isn’t immediately available in the news feed.
doesn’t support XML serialize, only JSON for chatter object.
Empty log entries in VARIABLE_ASSIGNMENT log events. for chatter.
cant be used in soap webserive . only rest . 

how to Moderate Chatter Private Message? 
create a before insert trigger on ChatterMessage sobject . get message and sender id.

how to moderate feed item ? 
create a before insert trigger on FeedItem sobject . get message and sender id , if any issues 
set status = 'PendingReview';

Communities :
Communities are branded spaces for your employees, customers, and partners to connect.
You can interact with communities in Apex using the Network class 
and using Chatter in Apex classes in the ConnectApi namespace.
ConnectApi.Communities class with methods that return information about communities.

Email : 

The email is received by the Apex email service, and processed by Apex classes that utilize the InboundEmail object.
implements Messaging.InboundEmailHandler 
handleInboundEmail()

Outbound Email:
Messaging.SingleEmailMessage
Messaging.MassEmailMessage
Messaging.sendEmail()

how to ensure org dont exceed daily email.
Messaging.reserveMassEmailCapacity(count);
Messaging.reserveSingleEmailCapacity(count);

after transaction commited - email sent.
All email that is returned, bounced, or received out-of-office replies goes to the user calling the method.
10 sendEmail methods per transaction

Messaging.SingleEmailMessage  -> setOrgWideEmailAddressId().
accepts object ID to an OrgWideEmailAddress object.
OrgWideEmailAddress.DisplayName field is used in the email header, instead of the logged-in user's Display Name.

metadata : 
metadata types and components to represent org configuration and customization

after or during app install -> create or update metadata.
create and use a custom ui to create custom metadata record , instead of Std UI.
Securely accessing protected metadata

Metadata.Operations class. for retireve and deploy
Metadata.Operations.retrieve() 
Metadata.Operations.enqueueDeployment() - async deployment (only create or update , no delete)
syntax : myPackage__MDType1__mdt.myPackage__Component1
install scripts -> review deploy - (InstallHandler interface)
uninstall script -> only review. - (UninstallHandler interface)

supported : 
Records of custom metadata types
Layouts

Protected metadata, such as a custom metadata type that’s been marked protected, 
can only be accessed by Apex classes in the same namespace as the protected metadata.

if the managed package is not approved by Salesforce -? setup -> apex setting ->
Deploy Metadata from Non-Certified Package Versions via Apex org preference should be enabled

Apex classes installed in the subscriber org can access any public, 
supported metadata type or component in the subscriber org

package can access and change metadata outside its namespace - > warning should be given.

Tests for deployment result code verify that your DeployCallback handles expected and unexpected results

create test DeployResults and DeployCallbackContext instances to test your DeployCallback.handleResults() method.


// Setup custom metadata to be created in the subscriber org.
    Metadata.CustomMetadata customMetadata =  new Metadata.CustomMetadata();
    customMetadata.fullName = 'ISVNamespace__MetadataTypeName.MetadataRecordName';

    Metadata.CustomMetadataValue customField = new Metadata.CustomMetadataValue();
    customField.field = 'customField__c';
    customField.value = 'New value';

    customMetadata.values.add(customField);

    Metadata.DeployContainer mdContainer = new Metadata.DeployContainer();
    mdContainer.addMetadata(customMetadata);

    // Setup deploy callback, MyDeployCallback implements
    // the Metadata.DeployCallback interface (code for
    // this class not shown in this example)
    MyDeployCallback callback = new MyDeployCallback();

    // Enqueue custom metadata deployment
    Id jobId = Metadata.Operations.enqueueDeployment(mdContainer, callback);

public class MyDeployCallback implements Metadata.DeployCallback {
    public void handleResult(Metadata.DeployResult result,
                             Metadata.DeployCallbackContext context) {
        if (result.status == Metadata.DeployStatus.Succeeded) {
            // Deployment was successful
        } else {
            // Deployment was not successful
        }
    }
}

Platform Cache:
platform Cache improves performance by distributing cache space,so one dont steal another.
cahce - > Salesforce session and org data 
cached data living alongside internally cached data,minimal disruption to core Salesforce processes.
Session, Org, SessionPartition, and OrgPartition classes.
In general, it’s more efficient to cache a few large items than to cache many small items separately.

Session cache(8 hours or  time-to-live which come first)—Stores data for individual user sessions.
eg: finds customers within specified territories, if diff location used , prev result reused via session cache.

Org cache( 48 hours or time-to-live expires)—Stores data that any user in an org reuses.
eg: based on userprofile display navigation bar menu dynamically.
org cache is accessible across sessions, requests, and org users and profiles.

best data : 
expensive to retrieve, static ,Reused 

Cache.Visibility enumeration to specify 
whether Apex code can access cached data in a namespace outside of the invoking namespace.

transaction fails , cache operation rolled back.

consideration : 
Cache isn’t persisted
modify apex class , some or all cache invalidated.
data not encrypted.
Org cache supports concurrent reads and writes across multiple simultaneous Apex transactions
this arbitrary choice is per key rather than per transaction
2 key updated in 2 transacation.
so randomly 1 key from first transation , 2 nd key from 2nd transation.no fix on particular transation.

cache miss happen , use cacheBuilder interface to check misses.
in lightning flow , if it has scheduled action or pause element -> make sure the later code dont involve 
session cache usage.
session cache limitation -> on apex actions and that do changes that causes trigger to fire.

session cahce :
single cached item - 100 KB max
local cache size for partition - > 500 kB 
Local cache is the application server’s in-memory container

org cache : 
local cache size for partition - > 1000 kB 
developer min time to live - 5 minutes

create partition -> allocate session and org cache for each part.

can distribute your org’s cache space across any number of partitions.

partition has no allocation,no cache operation invoked , no error returned.
no need of partition name for default partition.

while packaging explicitly add referenced partition explicitly.
Partition validation occurs during run time, not compile time.
don’t use the default partition in the package,deployment will fail.

Branch Packaging Orgs - share namespace across partitions.
maintain multiple org as branches of primary org.

least recently used (LRU) algorithm to improve performance.

Cache operations don’t interact with the caching layer directly, but instead interact with local cache.
cache layer -> local cache on reuquest and served from there hereafter.
Local cache doesn’t support concurrent operations
If session cache is used, the system removes cache evenly from all existing session cache instances.

The key name is in the format namespace.partition.key
default partition -> no need of namespace and partition.
local prefix refers to the namespace of the current org where the code is running
->local.myPartition.orderDate
The cache put calls are not allowed in a partition that the invoking class doesn’t own
Cache.Session.get() returns an object
Cache.SessionPartition sessionPart = Cache.Session.getPartition('myNs.myPartition');

use $Cache.Session or $Cache.Org global variable in vf page.
<apex:outputText value="{!$Cache.Session.myNamespace.myPartition.key1}"/>

class that implements cache builder interface.
<apex:outputText value="{!$Cache.Session.myNamespace.myPartition.CacheBuilderImpl_B_key1}"/>

Safely Cache Values with the CacheBuilder Interface
cache misses -> check for null or use cacheBuilder 
if no value exist doLoad method run , if value exists it get from cache.

class UserInfoCache implements Cache.CacheBuilder {
    public Object doLoad(String userid) {
        User u = (User)[SELECT Id, IsActive, username FROM User WHERE id =: userid];
        return u;
    }
}

User batman = (User) Cache.Org.get(UserInfoCache.class, ‘00541000000ek4c');
no need to use put();

classname+doLoad string argument make = unique value for cache.
do load alwyas return value and caste it .
class should be non static that implements the cache builder interface.

Use the System.currentTimeMillis() method for calculate the elapsed time.

Aggregate functions are available only for the Cache.Org class.
To retrieve multiple keys, call get(keys) in an initialization method.

Caching the class instance improves overall serialization size and performance.

This local cache eviction can cause unexpected misses and long serialization time and can waste resources.
The size of individual cached items is limited to 100 KB

Cache.Session usage is not expensive.
Cache.Org.getKeys() and Cache.Org.getCapacity() -> expensive 
bcoz org  traverse all partition-related
avoid contains and get but instead use get and check for null

Salesforce Connect
Apex code can access external object data via any Salesforce Connect adapter.
By default, external object records are read only. 

Salesforce Connect uses a protocol-specific adapter to connect to an external system
you specify the adapter in the Type field.

adapters are available for Salesforce Connect:
Cross-org(sf to sf), 
OData 2.0-OData 4.0 (The external data must be exposed via OData producers.),
Custom adapter created via Apex.

Salesforce Connect invokes methods in the Apex classes that compose the custom adapter.
when will be invoked : 
when click of tab to see list view.
views a record detail page
view related list
Salesforce global search.
DML opertation on record
run report
preview in  report builder.
accessed via flow,api,apex,soql,sosl.
validate or sync.

these features aren’t available for external objects-> Apex-managed sharing and trigger.
you can create triggers on external change data capture events from OData 4.0 connections

asynchronous timing and an active background queue minimize potential save conflicts.
Apex also lets you retrieve the results of delete and upsert operations.
BackgroundOperation object to monitor job progress for write operations via the API or SOQL

Database.insertAsync() methods can’t be executed in the context of a portal user,
even when the portal user is a community member.

add external object records via Apex, use Database.insertImmediate() methods.
batch Apex job against an external data source -> external records are stored in Salesforce while the job is running.
removed from storage when the job completes, 
No external data is stored during batch Apex jobs that use Database.QueryLocator.

if batch Apex with Database.QueryLocator to access external objects via an OData
 enable Request Row Counts on the external data source
 each response must include the total row count of the result set.
  enabling Server Driven Pagination on the external data source
  external system determine page sizes and batch boundaries for large result sets.
  server-driven paging more effective than client paging in adjust batch boundaries
  if Server Driven Pagination is disabled on the external data source
    OData adapter controls the paging behavior (client-driven)
   If external object records are added to the external system while a job runs, other records can be processed twice.
   if deleted other records skipped.

the batch size at runtime is the smaller of the following:
Database.executeBatch(scope value);
external system to return page sizes of 200 or fewer records.

can’t execute standard insert(), update(), or create() operations on external objects
DML on external objects are either asynchronous or executed when specific criteria are met.
SalesOrder__x -> __x for external objects.

Writes performed on external objects through the Salesforce user interface or the API are synchronous.

initiate an Apex method on an external object, a job is scheduled and placed in the background jobs queue. 

DataSource namespace to get the unique identifiers for asynchronous jobs,
or to retrieve results lists for upsert, delete, or save operations.

External Change Data Capture Packaging and Testing

managed packages, - > External Change Data Capture components & framework for testing your Apex triggers
select from Apex Class Component Type list -> trigger, test, external data source, external object, and other related assets
Certificates aren’t packageable
make sure that the subscriber org has a valid certificate with the same name.

EventBus.publish(event);
Test.getEventBus().deliver();

custom adapter for Salesforce Connect:
create two Apex classes: one that extends the DataSource.Connection class, 
and one that extends the DataSource.Provider class.

global class SampleDataSourceConnection
    extends DataSource.Connection {
    global SampleDataSourceConnection(DataSource.ConnectionParams
        connectionParams) {
    }
}

 sync() 
 on clicks of the Validate and Sync button 
 Changing the sync method on the DataSource.Connection class doesn’t automatically resync any external objects.
 override global List<DataSource.Table> sync() {
      List<DataSource.Table> tables =
            new List<DataSource.Table>();
        List<DataSource.Column> columns;
        columns = new List<DataSource.Column>();
        columns.add(DataSource.Column.text('Name', 255));
        columns.add(DataSource.Column.text('ExternalId', 255));
        columns.add(DataSource.Column.url('DisplayUrl'));
        tables.add(DataSource.Table.get('Sample', 'Title',
            columns));
        return tables;
 }

query()
soql on external object, user opens an external object’s list view or detail page in Salesforce.
DataSource.QueryContext is always only for a single table.
DataSource.QueryUtils class-> process query results locally within your Salesforce org(not supported on prod which use callout)
Complete the filtering and sorting on the external system before sending the query results to Salesforce
use server paging.

search()
sosl or global search 
 the DataSource.SearchContext can have multiple tables selected

upsertRows()
external object records are created or updated.
makePutCallout(),makePostCallout()

deleteRows()
use this makeDeleteCallout()

DataSource.Provider Class:
AuthenticationCapability.ANONYMOUS if no auth needed.

getAuthenticationCapabilities():
override global List<DataSource.AuthenticationCapability>
    getAuthenticationCapabilities() {
    List<DataSource.AuthenticationCapability> capabilities =
        new List<DataSource.AuthenticationCapability>();
    capabilities.add(
        DataSource.AuthenticationCapability.ANONYMOUS);
    return capabilities;
}

To allow SOQL :  DataSource.Capability.ROW_QUERY
To allow SOSL : DataSource.Capability.SEARCH 
 DataSource.Capability.ROW_CREATE and DataSource.Capability.ROW_UPDATE and  DataSource.Capability.ROW_DELETE

 override global List<DataSource.Capability> getCapabilities()
{
    List<DataSource.Capability> capabilities = new
        List<DataSource.Capability>();
    capabilities.add(DataSource.Capability.ROW_QUERY);
    capabilities.add(DataSource.Capability.SEARCH);
    capabilities.add(DataSource.Capability.ROW_CREATE);
    capabilities.add(DataSource.Capability.ROW_UPDATE);
    capabilities.add(DataSource.Capability.ROW_DELETE);
    return capabilities;
}

    override global DataSource.Connection getConnection(
        DataSource.ConnectionParams connectionParams) {
        return new sampleClassName(connectionParams);
    }
}

in external data source’s Type field specifies the correct DataSource.Provider class.

Key Concepts About the Apex Connector Framework:
the values of the External ID standard field on an external object come from the DataSource.Column named ExternalId.
Don’t use sensitive data as the values of the External ID ,because Salesforce sometimes stores those values.
display the External ID values of the parent records.
except high-data-volume external data sources, external id are stored.

DataSource.Provider class declares what types of credentials can be used to authenticate to the external system.
if  DataSource.AuthenticationCapability values that indicate support for authentication
 then the DataSource.Connection class is instantiated with a DataSource.ConnectionParams instance in the constructor.

The authentication credentials in the DataSource.ConnectionParams instance depend on the
Identity Type field of the external data source definition in Salesforce.

Identity Type is set to Named Principal, the credentials come from the external data source definition.
Identity Type is set to Per User : sync() ->  the credentials come from the external data source definition.
queries and searches() -> cred specific to user ,come from user’s authentication settings for the external system.

OAuth for Salesforce Connect Custom Adapters:
learn how to avoid access interruptions caused by expired access tokens.

automatically refresh access tokens as needed when:
valid refresh token from a previous OAuth flow.
DataSource.Connection class throws a DataSource.OAuthTokenExpiredException.
OAuth credentials -> remote service - > refresh token ->
DataSource.Connection class reconstructed with new oauth token in ConnectionParams.

requesting offline access:
add refresh_token to the Default Scopes field on the authentication provider definition in your Salesforce organization.

for other auth providers u must request offline access in the authentication URL as a query parameter. 
For example, with Google, append ?access_type=offline in auth endpoint URL Field.

To edit the authorization endpoint, select Open ID Connect in the Provider Type field of the authentication provider

Callouts for Salesforce Connect Custom Adapters:

requires authentication, incorporate the authentication parameters into the callout
Authentication parameters are encapsulated in a ConnectionParams object and provided to your DataSource.Connection

request.setHeader('Authorization', 'Bearer ' + 
            this.connectionInfo.oauthToken);

string encodedHeaderValue = EncodingUtil.base64Encode(Blob.valueOf(
            this.connectioninfo.username + ':' + 
            this.connectionInfo.password));
    request.setHeader('Authorization', 'Basic ' + encodedHeaderValue);

Named Credentials as Callout Endpoints: 
A named credential lets Salesforce handle the authentication logic for you so that your code doesn’t have to.
If all your custom adapter’s callouts use named credentials,
you can set the external data source’s Authentication Protocol field to No Authentication.
also no need of remote site.

Paging with the Apex Connector Framework:
server-driven paging(batch boundaries or page sizes that are specified in queries ignored), 
the external system to control the paging we need to enable:
declare the QUERY_PAGINATION_SERVER_DRIVEN capability in your DataSource.Provider class  
your Apex code must generate a *query token* and use it to determine and fetch the next batch of results.

client-driven paging, you use LIMIT and OFFSET clauses to page through result sets. 
in DataSource.QueryContext -> maxResults ,offset 

Custom adapters for Salesforce Connect don’t automatically support the queryMore method in API queries.
your implementation break large set to batches and iterate over them by using the queryMore method.
The default batch size is 500 records, but the query developer can adjust that value programmatically 

if server side: 
TableResult must provide a queryMoreToken value.arbitrary string that we store temporarily
pass the query token back to your custom adapter in the DataSource.QueryContext
Apex code determine next batch of results. 
final batch -> no queryMoreToken value.

if client drived: 
declare the QUERY_TOTAL_SIZE capability in your DataSource.Provider class
 DataSource.TableResult will return total size
 total size > result
we generate a nextRecordsUrl link and set the done flag to false

if total record capability not supported : 
our query is has limit 5 
DataSource.QueryContext that has the maxResults property set to 6.
if 6 present or not we can determine more data is there.
We assume, however, that the data set we query against doesn’t change between queries.

COUNT() query, the selected column has the value QueryAggregation.COUNT in its aggregation property.
DataSource.QueryContext.tableSelection.columnsSelected.get(0).aggregation = QueryAggregation.COUNT

DataSource.QueryContext - >  1  DataSource.TableSelection
DataSource.SearchContext -> *many DataSource.TableSelection has filter property.

Evaluating Filters in the Apex Connector Framework: 
A filter evaluates to true for a row if that row matches the conditions that the filter describes.
DataSource.Filter has 
columnName set to meaningOfLife, 
columnValue set to 42, 
and type set to EQUALS.

for performance : 
do all the filtering in the external system
translate the Filter object into a SQL or OData query, or map it to parameters on a SOAP query.
filter in client cause governor limits.

Filters can have child filters, which are stored in the subfilters property.
Filter type must be one of the following.
NOT_ OR_ AND_
DataSource.FilterType.AND_

consideration : 
change and save a DataSource.Connection class, resave the corresponding DataSource.Provider class
else , the custom adapter doesn’t appear as an option for the Type field
DML operations aren’t allowed in the Apex code that comprises the custom adapter.
external systems accept only requests for up to 40 rows

Double—The value loses precision beyond 18 significant digits,for higher use decimal.
String—If the length is greater than 255 characters, the string is mapped to a long text area
Custom adapters  has all governor limit

In Apex tests, use dynamic SOQL to query external objects.
Tests that perform static SOQL queries of external objects fail
Test methods don’t support web service callouts. use if (System.Test.isRunningTest()) {return mock response}

Salesforce Reports and Dashboards API via Apex
programmatic access to your report data as defined in the report builder.

you might use the API to trigger a Chatter post with a snapshot of top-performing reps each quarter.

Integrate report data into custom objects.
Integrate report data into rich visualizations to animate the data.
Build custom dashboards.
Automate reporting tasks

Run tabular, summary, or matrix reports synchronously or asynchronously.
Filter for specific data on the fly.
Query report data and metadata.

limitation : 
Cross filters, standard report filters, and filtering by row limit are unavailable.
Historical tracking reports are only supported for matrix reports,subscription not supported.
only 100 fields selected as columns.
list of up to 200 recently viewed reports returned.
500 synchronous report runs per hour.
20 synchronous report run requests at a time.
2,000 instances of a report that was run asynchronously.
200 requests at a time to get results of asynchronous report runs
1,200 asynchronous requests per hour.
Asynchronous report calls are not allowed in batch Apex.
Report calls are not allowed in Apex triggers.
no Apex method to list recently run reports.
sync report processed row =  50,000 
There is no way to disable the SeeAllData annotation for a report execution in apex test.

Run Reports:
the API returns data for the same number of records that are available when the report is run in the Salesforce user interface.
asynchronously adv : 
long -running reports have a lower risk of reaching the timeout
two-minute overall Salesforce API timeout limit doesn’t apply to asynchronous runs.

sync run : 
Reports.ReportResults results = Reports.ReportManager.runReport(reportId, true);
asnyx run : 
Reports.ReportInstance instance = Reports.ReportManager.runAsyncReport(reportId, true);
Reports.ReportManager.getReportInstances(reportId)
Report results are stored for a rolling 24-hour period.

retrieve report metadata to get information about a report and its report type.
ReportResults.getReportMetadata method to retrieve report metadata.
Reports.ReportMetadata rm = results.getReportMetadata();
rm.getName(); // like wise get related metadata.

data :
ReportResults class to get the fact map, which contains data that’s associated with a report.
 imagine that you have an opportunity report that’s grouped by close month, and you’ve summarized the amount field.
 
Reports.GroupingValue GroupingValue = results.getGroupingsDown().getGroupings()[0];
factMapKey = GroupingValue.getKey()+'!T'; //generate factmap key
Reports.ReportFactWithDetails   = results.getFactMap().get(factMapKey);
details.getAggregates()[0]; //first summary amount.

Changes to filters that are made through the API don’t affect the source report definition.

The ReportTypeColumn.getFilterable method tells you whether a field can be filtered.
The ReportTypeColumn.filterValues method returns all filter values for a field.
The ReportManager.dataTypeFilterOperatorMap method lists the field data types that you can use to filter the report.
The ReportMetadata.getReportFilters method lists all filters that exist in the report.

retrieves the report metadata, overrides the filter value, and runs the report.
 ReportFilter.setValue method

// Get the report metadata
Reports.ReportDescribeResult describe = Reports.ReportManager.describeReport(reportId);
Reports.ReportMetadata reportMd = describe.getReportMetadata();
Reports.ReportFilter filter = reportMd.getReportFilters()[0];
filter.setValue('2013-11-01');
(Reports.ReportFactWithSummaries)results.getFactMap().get('T!T');

report results can contain values for only summary or both summary and detailed data.
The fact map values are expressed as keys, which you can programmatically use to visualize the report data

key pattern : 
Tabular - T!T:
Summary - !T

The Reporting Apex methods don’t run in system mode, they run in the context of the current user 

Salesforce Sites: 
manage your Salesforce sites in Apex using the methods of the Site and Cookie classes.

To rewrite URLs for a site, create an Apex class that maps the original URLs to user-friendly URLs,
and then add the Apex class to your site.

global class yourClass implements Site.UrlRewriter {
    global PageReference mapRequestUrl(PageReference
            yourFriendlyUrl)
    global PageReference[] generateUrlFor(PageReference[]
            yourSalesforceUrls);
}

Incoming URL requests can only be mapped to Visualforce pages associated with your site.
You can't map to standard pages, images, or other entities.

To rewrite URLs for links on your site's pages:
<apex:outputLink value="{!URLFOR($Page.myPage)}"></apex:outputLink>

Visualforce <apex:form> elements with forceSSL=”true” aren't affected by the urlRewriter.
except for the .well-known path component, which can’t be used at the end of a URL. -> no period in URL

String emailThreadId = '_00Dxx1gEW._500xxYktg';
        // Call Apex method to retrieve case ID from email thread ID 
        ID caseId = Cases.getCaseIdFromEmailThreadId(emailThreadId);

BusinessHours bh = [SELECT Id FROM BusinessHours WHERE IsDefault=true];
Datetime startTime = Datetime.newInstance(2008, 5, 28, 1, 6, 8);
after one business hour
Datetime nextTimeGmt = BusinessHours.addGmt(bh.id, startTime, 60 * 60 * 1000L);

you can write trigger on it:
UserTerritory2Association -> users have been added to territories
Territory2  - > territory for each TerritoryModel(Territory2Model)

flows : 
you can create a flow to script calls for a customer support center
generate real-time quotes for a sales team. 
embed a flow in a Visualforce page or Aura component and access it in an Apex controller.

Flow.Interview Apex class provides the getVariableValue method for retrieving a flow variable

public Flow.Interview.Flow_Template_Gallery myFlow {get; set;}
myFlow.getVariableValue('vaBreadCrumb');

Process.Plugin interface to pass Passing Data to a Flow.
The interface exposes Apex as a service, which accepts input values and returns output back to the flow.
@InvocableMethod annotation instead of the Process.Plugin interface.
Once you implement the interface on a class, the class can be referenced only from flows.

The annotation supports all data types and bulk operations. 
Once you implement the annotation on a class, the class can be referenced from flows,
processes, and the Custom Invocable Actions REST API endpoint.
