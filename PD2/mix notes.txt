Annotations : 

@AuraEnabled 
client- and server-side access to an Apex controller method
available to your Lightning components (both Lightning web components and Aura components). 
Only methods with this annotation are exposed.

improve runtime performance by caching method results on the client by using the annotation @AuraEnabled(cacheable=true).
only on retrieval not  but do not use in modify records 

@deprecated
can no longer be referenced in subsequent releases of the managed package
useful when you are refactoring code in managed packages
New subscribers cannot see the deprecated elements
dep elements continue to function for existing subscribers and API integrations.

Unmanaged packages cannot contain code that uses the deprecated keyword.
all global access modifiers that reference the deprecated identifier must also be deprecated.
But still be referenced internally by the package developer.
webservice methods and variables cannot be deprecated.
deprecate an enum but you cannot deprecate individual enum values.
deprecate an interface but you cannot deprecate individual methods in an interface.
deprecate an abstract class but you cannot deprecate individual abstract methods in an abstract class.
can't remove the deprecated annotation to undeprecate something in Apex 
after you have released a package version where that item in Apex is deprecated.

@future
methods that are executed asynchronously
parameters must be primitive data types
must be static methods, and can only return a void type
@future (callout=true)
Methods with the future annotation cannot be used in Visualforce controllers 
in either getMethodName or setMethodName methods, nor in the constructor.

u can't call trigger from a annotated method that calls another annotated method.

@InvocableMethod
InvocableMethod annotation to identify methods that can be run as invocable actions.
a flow invokes Apex, the running user must have the corresponding Apex class security set in their user profile or permission set.

used to invoke a single Apex method.
Invocable methods have dynamic input and output values and support describe calls.
@InvocableVariable for variables

Considerations:
outer class , method public or global , static
Only one method in a class can have the InvocableMethod annotation.
Input 
at most one input parameter

once you add an invocable method you can’t remove it from later versions of the package
Public invocable methods can be referred to by flows and processes within the managed package.
Only global invocable methods appear in Flow Builder and Process Builder in the subscriber org.

InvocableVariable Considerations: 
Only global and public variables can be invocable variables.
cant be final,private,protected,static , non member variable.

@isTest:
class and method can be private or public
must be top-level classes.
Classes defined as @isTest can't be interfaces or enums
Non-test requests cannot call public methods.
@isTest(SeeAllData=true) 
@isTest(SeeAllData=true) and @isTest(isParallel=true) cannot be used together on the same Apex method

@isTest(OnInstall=true)
specify which Apex tests are executed during package installation.
It is no longer possible to bypass a failing test during package installation

@isTest(isParallel=true) test classes that can run in parallel.
This annotation makes the execution of test classes more efficient,

@namespaceAccessible:
Without this annotation, Apex classes, methods, interfaces, and properties 
defined in a 2GP package aren’t accessible to the other packages with which they share a namespace.
can't use the @namespaceAccessible annotation for an @AuraEnabled Apex method
add or remove the @namespaceAccessibleannotation at any time,

@ReadOnly:
while removing the limit of the number of returned rows for a request, 
blocks you from performing the following operations within the request: 
DML operations, calls to System.schedule, calls to methods annotated with @future, and sending emails.

To use the @ReadOnly annotation, the top level request must be in the schedule execution or the Web service invocation
if a Visualforce page calls a Web service that contains the @ReadOnly annotation, 
the request fails because Visualforce is the top level request, not the Web service.
Vf page -> controller with readonly , run as relaxed limit.
readonly attribute on the <apex:page> tag to true. ->
  increase other Visualforce-specific limits, such as the size of a collection

@RemoteAction
Apex methods used in Visualforce to be called via JavaScript.
method : static , global or public 
[namespace.]controller.method(
    [parameters...,]
    callbackFunction(status,result),
    [configuration]
);

configuration- change the behavior of a remoting call

@SuppressWarnings annotation does nothing in Apex but can be used to provide information to third party tools.

@testSetup:
creating common test records that are available for all test methods in the class.
the testing framework executes the test setup method first, before any test method in the class.
The next executing test method gets access to the original unmodified state of those records
only one test setup method per test class.

if there @isTest(SeeAllData=true) annotation, test setup methods aren’t supported in this class.

@TestVisible :
allow test methods to access private or protected members of another class outside the test class


@RestResource annotation is used at the class level and 
enables you to expose an Apex class as a REST resource.
Apex class must be defined as global.

url mapping 
begin with /*/*
have wildcard
no exact match is found, find all the patterns with wildcards that match, and then select the longest (by string length) of those.
no wildcard match is found, an HTTP response status code 404 is returned.
/services/apexrest/namespace/your_url/

 @HttpDelete
 HTTP DELETE request is sent, and deletes the specified resource.
 Apex method must be defined as global static.

 @HttpGet
 HTTP GET request is sent, and returns the specified resource.
 Apex method must be defined as global static.
 called also when HTTP request uses the HEAD request method.

 @HttpPatch
HTTP PATCH request is sent, and updates the specified resource.

@HttpPost
HTTP POST request is sent, and creates a new resource.

@HttpPut
HTTP PUT request is sent, and creates or updates the specified resource.

Apex Actions:
Invoke Apex methods annotated with @InvocableMethod and include custom parameters with @InvocableVariable.

get list of avaialbe action : 
/vXX.X/actions/custom/apex
get specific action info:
/vXX.X/actions/custom/apex/action_name

The resource is the name of the Apex class, not the Apex method. 
In this example, the resource is /ActionTest, not /getAccountNames.

respect the profile access for the Apex class. If you don’t have access, an error is issued.
remove the @InvocableMethod annotation from the Apex class, you get a runtime error in the flow.


core calls : 

convertLead()
Converts a Lead into an Account, Contact, or (optionally) an Opportunity.
permission -> edit on lead ,create and edit on acc,contact,opp.
a lead can be converted as soon as it becomes a real opportunity that you want to forecast.

if data is merged into existing account, contact, and opportunity objects,
then only empty fields in the target object are overwritten.

if overwriteLeadSource is true 
LeadSource field in the target Contact object will be overwritten with the contents of the LeadSource field in the source Lead object.

standard fields auto mapped.
the default record type of the new owner is assigned to records created during lead conversion
assigns the default picklist values
if string is long error thrown , not truncated.
else 
use the AllowFieldTruncationHeader SOAP header.

if any error the lead conversion is retried for each lead individually.

the lead owner is unsubscribed from the lead record’s Chatter feed
unless they have automatic subscriptions enabled in their Chatter feed,they dont subscribe to new rec.

best practice :  after convertLead()
the client application creates tasks in which the WhoId is the ContactId and, 
if an opportunity is created, the WhatId is the OpportunityId.

converting leads owned by a queue, the owner must be specified. 
accounts and contacts cannot be owned by a queue.

syntax:convertLead(List<LeadConvert> ) {max 100}

LeadConvert[] leadsToConvert = new LeadConvert[saveResults.Length]; ;
LeadConvertResult[] lcResults =binding.convertLead(leadsToConvert);

SELECT Id, MasterLabel FROM LeadStatus WHERE IsConverted=true
to get all valid lead status

LeadConvert Arguments
accountId-> if u want to merge to existing acc,not value overwritten.
contactId-> specify account id and related contact id to merge,overwriteLeadSource true ? leadSource overwritten.
if to person account dont specify contact.
doNotCreateOpportunity - > by default oppp created with company name, make true to stop.
leadId-> 
opportunityId-> merge to exisiting
opportunityName-> op name , if no specified  defaults to the company name of the lead.
dont specify both  opportunityId and opportunityName.
if doNotCreateOpportunity  is true dont specify oppName.
ownerId -> owner of new records.
sendNotificationEmail -> true email for owner 

convertLead return LeadConvertResult:
has boolean success , array of errors

create():
one or more new records to your organization’s data.
you might also need permissions to access the object’s parent object. 
Before you attempt to create() a record for a particular object.

Only objects where createable is true can be created via the create() call
invoke the describeSObjects() call on the object and inspect its createable property.
if you do not override OwnerID,it takes  user as whom your client application is logged in.
if non req field , value will be null,
you must supply the foreign key information that links the child to the parent. 
API trims any leading and trailing whitespace

AllowFieldTruncationHeader SOAP header if not specified , long string throw error.

accounts fire Territory Management assignment rules.

populate AssignmentRuleHeader to have the case or lead automatically assigned to one or more users
based on assignment rules configured in the Salesforce user interface.

200 records in a single create() call
AllOrNoneHeader header allows you to roll back 
Automatically follow records that I create option in their personal settings to subscribe.

use DisableFeedTrackingHeader. don't want to track the changes in various feeds related to the records
can create records for multiple object types, including custom objects, in one call 
up to 10 object types in one call.
the parent record must precede the child record in the sObjects array.
contact references the account by using an External ID field.
can't add a record that references another record(in the array) of the same object type in the same call.

record of diff obj type -> broken to chunks ->each chunk(each object)
10 chunks in one call bcoz only 10 object supported in one call.

except user,group,groupmember, custom setting , any insert in setup object along with custom  throw error mix DML.

how to create parent and child in same call : 
use external ID fields as foreign keys to create parent and child records 
create child
create parent only populate external id
set as parent for child
create one more record for parent set same external id,fill other fields.
pass parent with field populated and child .

 SaveResult[] = create(List<Sobject>)

 delete():
 one or more records from your organization’s data.
 also need permission to access this object’s parent object
 to ensure referential integrity
 If you delete a parent object, you delete its children automatically, 
object must be configured as deletable (deletable is true) . for used in delete().

mix object(setup and normal) delete cause error.
except those 4.

AllOrNoneHeader allow rollback on error.
takes list of id as input
DeleteResult[] deleteResults = connection.delete(ids);

deleteByExample()
to delete big object data from your org using an sObject as a template for what to delete

Define an sObject using all the fields that make up the index of the big object.
all matching row with value specified will be deleted.

sObject[] fieldHistoryArchive_1 = new sObject();
//how to delete records in FieldHistoryArchive.
fieldHistoryArchive_1.setType("FieldHistoryArchive");
or
customerBO.setType("Customer_Interaction__b");
DeleteByExampleResult[] result = connection.deleteByExample(sObjectsToDelete);

emptyRecycleBin()
view and restore recently deleted records for 15 days before they are permanently deleted.
5,000 records per license

After records are deleted from the Recycle Bin using this call, 
they can be queried using queryAll() for some time

Do not include the IDs of any records that will be cascade deleted.

executeListView():
Executes a list view’s SOQL query to retrieve data, labels, and actions from a list view.
executeListView() call takes an ExecuteListViewRequest object, 
executes the SOQL query for the list view, and returns the resulting data

ExecuteListViewRequest(developerNameOrId,limit,offset,sobjectType)
ExecuteListViewResult(record,column,size)
ListViewColumn - a single list view column.
Represents a single row in a list view. - ListViewRecord
ListViewRecordColumn -  single cell in a row from a list view.

findDuplicates()
Performs rule-based searches for duplicate records
All the sObject elements in the input array must have the same type, object type that supports duplicate rules.
 apply duplicate rules associated with an object to values specified by each sObject

Record ID only - find record with the specified id -> it loads the values from that record, and searches for duplicates based on those values.
Field Map only -  loads the values from the map and searches for duplicates based 
both given - loads any values from that record that aren’t specified in the map, and then loads values from the map , union it 
find duplicated return FindDuplicatesResult

findDuplicatesByIds()
IDs, each of which specifies the records for which to search for duplicates. 
doesn’t find any duplicates for an sObject, 
the duplicateRule field in DuplicateResult contains the name of the duplicate rule that findDuplicatesByIds() applied, 
but the matchResults array is empty.
using the record id get the value and search for the record related duplicate and return object with duplicate results.

includeRecordDetails - false only id returned else all fields in primary compact layout.
FindDuplicatesResult is returned

getDeleted()
list of individual records that have been deleted within the given timespan
used by data replication applications

Deleted records are written to a delete log, 
A background process that runs every two hours purges records that have been in an organization's delete log for more than two hours
if limit is reaching

INVALID_REPLICATION_DATE error is returned. If you get this exception, you should do a full pull of the table.
so earlier  to 2 hours u should run to check for data replication.

getUpdated()
the list of individual records that have been updated (added or changed) within timespan
if an opportunity were to become closed, a client application might run a new revenue report.
latestDateCovered - the value in this field is the start time of that long-running transaction until it completes.

invalidateSessions()
his call to end one or more sessions.

You can also use logout() to end just one session, the session of the logged-in user

login(string username, string password);
 add the security token at the end of the user’s password. 
obtains a sessionId and server URL before making other API calls.

Sets the session ID in the SOAP header so that the API can validate subsequent requests for this session

Multiple client apps can log in using the same username argument.
A user can have up to 10 query cursors open at a time
if new one opened ,then the oldest of the 10 cursors is released.

limit is 3,600 calls to login() per user per hour. 
set the proxy host and port number on the instance of the ConnectorConfig class that you use to log in. 

active self-service users,
use LoginScopeHeader to specify the Organization ID against which self-service users are authenticated

merge()
Combines up to 3 records of the same type into 1 record.
input is an array of MergeRequest elements
output is a MergeResult object
If a victim record has related records, merge() makes the master record the new parent of the related records.
Use queryAll() to view records that have been deleted during a merge.
The supported object types are Lead, Contact, Account, Person Account, and Individual. 
To merge more than 3 records, do a successive merge.
most recently updated data privacy record or data privacy record already associated with the master record.(any 1 picked)

performQuickActions()
Executes quick actions of type create or update.
Only one record can be saved at a time.

process()
array of approval process instances for approval
array of approval process instances to be approved, rejected, or removed

query()
Executes a query against the specified object and returns data that matches the specified criteria.
you should not use describe to populate a select list, if anything added after consume , result error.
use queryAll() to query on all Task and Event records, archived or not. 
query(), it automatically filters out all records where isArchived is set to true
500 rows of data by default.
increase the default size up to 2,000 in the queryOption header.

queryLocator-specialized string, similar to ID. 
Used in queryMore() for retrieving subsequent sets of objects from the query results.

 For example, you can have 10 query cursors open and 10 Metadata API cursors at the same time.
 QueryLocator represents a server-side cursor.

 queryAll()
Retrieves data from specified objects, whether or not they have been deleted.
connection.queryMore(qr.getQueryLocator());

can't use queryMore() if a query includes a GROUP BY clause.

OData adapters convert each queryMore() call into an OData query
that uses the $skip and $top system query options to specify the batch boundary and page size.
similar to using LIMIT and OFFSET 

retrieve()
Retrieves one or more records based on the specified IDs.
retrieve() call to retrieve individual records from an object.
does not return records that have been deleted

search()
Executes a text search in your organization’s data.
Certain objects cannot be searched via the API, such as Attachment objects
takes sosl query 

undelete()
Undeletes records from the Recycle Bin.
Account records can be undeleted, but not AccountTeamMember records.

update()
Updates one or more existing records in your organization’s data.

Maximum number of duplicate updates in one batch (12 allowed).
to make it null, you add the field name to the fieldsToNull array in the sObject

upsert()
On standard objects, this call can use the name of any field with the idLookup field property instead of the external ID.
this call uses an indexed custom field called an external ID on custom object.

External ID fields cannot be used with merge().
uses externalIdFieldName and records as input 

Choose the Right Automation Tool:
Lightning Flow are two point-and-click automation tools:
Process Builder, which lets you build processes, and Flow Builder, which lets you build flows.

Create a guided tutorial or wizard with screens.? 
Flow Builder , also add aura componenet to screens

Set up automated tasks and processes.?
Process Builder or Flow Builder. If needed, you can build custom Apex code to fill any functional gaps.

Connect to external systems.? 
Process Builder and Flow Builder let you respond to and send platform event messages
 In addition, Flow Builder can retrieve data from third-party systems with External Services.

Add automation to your pages and apps?
 behind-the-scenes processes start when the right action happens
 when , whether that’s when records change or when users click a particular button.

Reuse what you build.?
any flow can be used as a subflow.
, create an invocable process to reuse.

Behind-the-scenes automation - Process Builder Flow Builder Apex
Approval automation	 - Approvals

Process builder : 
A record is created
A record is updated
A platform event occurs

Flow Builder:
Automate a guided visual experience.
need more fn than process builder.
Start a behind-the-scenes business process when a user clicks something, like a button.

Guide a community member through requesting a new credit card with a step-by-step wizard.
-Flow Builder	

A sales rep clicks a button on an opportunity, which launches a discount calculator.	
-Flow Builder	

When an account is updated, update all of the contacts related to that account.	
-process builder

When an opportunity stage is updated, also update a custom checkbox field.
- process builder

Create a task when a platform event occurs.	
-process builder

Update a lead record in Salesforce after a certain amount of time passes, or when a specified time is reached.	
-process builder

When an opportunity closes, automatically create a renewal opportunity.	
-Process Builder and Flow Builder both(you can build parts of that use case as a process, but the rest has to be built in a flow)

Route an employee’s time-off request to a manager for approval.	
-approval

Debugging Apex:

Debug Log
has 
Automated workflow processes, such as:
Workflow rules
Assignment rules
Approval processes
Validation rules

does not include information from actions triggered by time-based workflows.
header  of log contains - >  log category and level used to generate the log.

Be particularly careful with processes 
such as community users self-registration where user passwords may be assigned to an Apex string variable.
bcoz finest level has Apex variable assignments details.

execution unit is equivalent to a transaction
code unit is a discrete unit of work within a transaction
eg: trigger,webserice,validation.
A class is not a discrete unit of code.


Debug log filtering provides a mechanism for fine-tuning the log verbosity at the trigger and class level.
these debug levels also apply to the class methods that your class or trigger calls and the triggers that get executed as a result. 

logging order of precedence: 
Trace flags override all other logging logic

Setting class and trigger trace flags doesn’t cause logs to be generated or saved. 
Class and trigger trace flags override other logging levels,
including logging levels set by user trace flags, but they don’t cause logging to occur. 

API requests that are sent without debugging headers generate transient logs—logs not saved.

Exceptions in Apex:

handle errors in your code, including using assertions like System.assert calls, or returning error codes or Boolean values
Exceptions bubble up until it reach catch, so no need to write each of methods.
finally statements- recover from exception , resetting variables and deleting data.

when exception occurs ? 
code execution halts. 
Any DML operations that were processed before the exception are rolled back and aren’t committed to the database
Exceptions that the code doesn’t catch, Salesforce sends an email that includes the exception information
emails are sent that include the Apex stack trace, exception message, and the customer’s org and user ID
to the developer specified in the LastModifiedBy field
Tooling API object ApexEmailNotification.
only the first email is sent,incase of duplicate exception.

Each catch statement must have a unique exception type.
one try -> one finally associated.
At least a catch block or a finally block must be present with a try block. 
One such exception is the limit exception (System.LimitException) - cant be caught
assertion statements fail (through System.assert methods) or license exceptions. - cant be caught.
exceptions are uncatchable, catch blocks, as well as finally blocks if any, aren’t executed.
unreachable statements in your code will cause compilation errors.

built In exception : 
DmlException 
ListException 
NullPointerException 
QueryException:
->such as assigning a query that returns no records or more than one record to a singleton sObject variable.
SObjectException:-attempting to change a field in an update statement that can only be changed during insert.
->queries an invoice statement and selects only its Name field. 
->It then attempts to get the Description__c field on the queried sObject

why getCause returned null?
there was no previous exception (inner exception) that caused this exception. 

DmlException methods : 
getDmlFieldNames() -> names of the fields that caused the error for the specified failed record
getDmlId-> record id
getDmlMessage-> message
getNumDml-> no of failed records .

can’t throw built-in Apex exceptions,can only catch them.
Custom exceptions enable you to specify detailed error messages
extend the built-in Exception class and 
make sure your class name ends with the word Exception, such as “MyException” 
user-defined exception types can form an inheritance tree,

construct exceptions:
new MyException();
new MyException('This is bad');
new MyException(e);
new MyException('This is bad', e);
can rethrow the caught exception as an inner exception in your custom exception 
and have the main method catch your custom exception type.

calling the getCause method-> wont be null now.
catch a system exception,new MyException('This is bad', e); -> using this throw custom exception with original exception.

Stack trace is  showing  which is the second time an exception was thrown.

Apex Managed Sharing:
granting a user or group of users permission to perform a set of actions on a record or set of records.
set an object’s organization-wide default sharing access level
then 
grant additional access based on record ownership, the role hierarchy, sharing rules, and manual sharing.
Most sharing for a record is maintained in a related sharing object,

managed sharing involves sharing access granted by Force.com based on record ownership, the role hierarchy, and sharing rules:

Record Ownership:
Each record is owned by a user or optionally a queue -> who has automatically granted Full Access

Role Hierarchy:
role hierarchy enables users above another user in the hierarchy
to have the same level of access to records owned by or shared with users below

user above owner in role hierarcy has full access to owner records , but can be disabled for specific custom objects
role hierarchy is not maintained with sharing object records,its runtime.

Sharing Rules:
Sharing rules are used by administrators to automatically grant users within a (given group
or role access) to records owned by a specific group of users.

Sharing rules cannot be added to a package
Sharing rules can be based on record ownership or other criteria

can’t use Apex to create criteria-based sharing rules.
Also, criteria-based sharing cannot be tested using Apex.

implicit sharing added by Force.com managed sharing -> cant be altered.

Manual Sharing:
user with Full Access to a record to share the record with a user or group of users.
generally done by an end-user, for a single record.

Only the record owner and users above the owner in the role hierarchy are granted Full Access to the record
It is not possible to grant other users Full Access

User managed sharing is removed :
when record owner changes or 
when access granted in the sharing does not grant additional access beyond object's organization-wide sharing.

This type of sharing is similar to Force.com managed sharing.
Only users with “Modify All Data” permission can add or change Apex managed sharing on a record.
Apex managed sharing is maintained across record owner changes.

Apex sharing reasons and Apex managed sharing recalculation are only available for custom objects.

The Reason field on a custom object specifies the type of sharing used for a record.
field is called rowCause in Apex or the Force.com API.

displayed reason for Apex managed sharing is defined by the developer.
the most permissive level of access is used.

Private-> Only the record owner and users above the record owner in the role hierarchy can view and edit the record. 
This access level only applies to the AccountShare object.

Read Only	->
Read/Write	->
Full Access	-> can only be granted with Force.com managed sharing.

AccountShare is the sharing object for the Account object,
MyCustomObject__Share for custom object 

Objects on the detail side of a master-detail relationship do not have an associated sharing object.
detail record’s access is determined by the master’s sharing object and the relationship’s sharing setting.

share object : 
supporting all three types of sharing: Force.com managed sharing, user managed sharing, and Apex managed sharing. 
what all not tracked here : 
organization-wide defaults, 
the role hierarchy,
and permissions such as the “View All” and “Modify All” permissions for the given object,
“View All Data,” and “Modify All Data” for profile.

fields: 
objectNameAccessLevel -> Edit,Read,All(given only by force managed sharing).
field must be set to an access level that is higher than the organization’s default access level.

ParentID->
RowCause->
UserOrGroupId->
Apex sharing is not available for Customer Community users. 

rowCause -> jobShr.RowCause = Schema.Job__Share.RowCause.Manual;
we can create custom also 
custom object-> New in the Apex Sharing Reasons related list.
Schema.Job__Share.rowCause.Recruiter__c

User Managed Sharing Using Apex
it uses the reason manual(default)
Creating Apex Managed Sharing
Apex managed sharing is maintained across record owner changes.
Apex managed sharing must use an Apex sharing reason.
Apex sharing reasons are a way for developers to track why they shared a record with a user or group of users
share with the same user or group multiple times using different reasons.

inserting a share row results in an update of an existing share row.
->If a manual share access level is set to Read,new one that’s set to Write, original share rows are updated to Write.
->users can access an account because they can access its child records.
an account sharing rule is created,row cause of the parent implicit share is replaced by the sharing rule row cause(defined by us)

Recalculating Apex Managed Sharing:

Salesforce automatically recalculates sharing for all records on an object 
when its organization-wide sharing default access level changes
The recalculation adds Force.com managed sharing when appropriate.
all types of sharing are removed if the access they grant is considered redundant

go to classic to see this: apex sharing reason and recalculcation realted list 
must write an Apex class that implements a Salesforce-provided interface(Database.Batchable<sObject>) to do the recalculation

if a locking issue prevented Apex code from granting access to a user as defined by the application’s logic
- recalcualted.

For custom objects, this is Public Read/Write. - most permissive level.


